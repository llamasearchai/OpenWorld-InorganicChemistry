#!/usr/bin/env bash
# scipaper-all-in-one.sh
# One-shot macOS setup: scaffolds full scipaper-cli repo, installs deps, tests, launches server, and provides a CLI.
# No placeholders, no stubs. Safe OA-first (arXiv) functionality; optional Agent endpoint returns 501 if SDK not installed.

set -euo pipefail

APP_NAME_BASE="scipaper-cli"
TIMESTAMP="$(date +%Y%m%d%H%M%S)"
APP_DIR="${APP_NAME_BASE}"
if [ -d "${APP_DIR}" ]; then
  APP_DIR="${APP_NAME_BASE}-${TIMESTAMP}"
fi

HOST="127.0.0.1"
PORT="8000"
RUN_DIR=".run"
PID_FILE="${RUN_DIR}/uvicorn.pid"
LOG_FILE="${RUN_DIR}/uvicorn.log"

say()  { printf "\033[1;36m%s\033[0m\n" "$*"; }
warn() { printf "\033[1;33m%s\033[0m\n" "$*"; }
err()  { printf "\033[1;31m%s\033[0m\n" "$*" >&2; }
exists(){ command -v "$1" >/dev/null 2>&1; }

ensure_python() {
  if ! exists python3; then
    warn "python3 not found. Attempting to install via Homebrew..."
    if ! exists brew; then
      /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      if exists brew; then
        eval "$("$(command -v brew)" shellenv)"
      else
        err "Homebrew installation failed. Install Python 3.9+ and re-run."
        exit 1
      fi
    fi
    brew install python
  fi
  PY_VER="$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')"
  PY_MAJ="${PY_VER%%.*}"; PY_MIN="${PY_VER#*.}"
  if [ "${PY_MAJ}" -lt 3 ] || [ "${PY_MIN}" -lt 9 ]; then
    err "Python >= 3.9 required. Found ${PY_VER}. Please upgrade."
    exit 1
  fi
}

start_server_bg() {
  mkdir -p "${RUN_DIR}"
  if [ -f "${PID_FILE}" ] && kill -0 "$(cat "${PID_FILE}")" 2>/dev/null; then
    warn "Server already running (PID $(cat "${PID_FILE}"))."
    return 0
  fi
  say "Starting FastAPI server in background on http://${HOST}:${PORT} ..."
  nohup .venv/bin/python -m uvicorn scipaper.main:app --host "${HOST}" --port "${PORT}" > "${LOG_FILE}" 2>&1 &
  echo $! > "${PID_FILE}"
  sleep 1
  if ! kill -0 "$(cat "${PID_FILE}")" 2>/dev/null; then
    err "Server failed to start. Check ${LOG_FILE}."
    exit 1
  fi
}

stop_server_bg() {
  if [ -f "${PID_FILE}" ] && kill -0 "$(cat "${PID_FILE}")" 2>/dev/null; then
    say "Stopping server (PID $(cat "${PID_FILE}")) ..."
    kill "$(cat "${PID_FILE}")" || true
    rm -f "${PID_FILE}"
  else
    warn "No running server found."
  fi
}

health_check() {
  say "Health check → http://${HOST}:${PORT}/api/v1/health"
  for i in {1..20}; do
    if curl -fsS "http://${HOST}:${PORT}/api/v1/health" >/dev/null; then
      curl -fsS "http://${HOST}:${PORT}/api/v1/health"; echo
      return 0
    fi
    sleep 0.5
  done
  err "Health check failed."
  exit 1
}

status_server() {
  if [ -f "${PID_FILE}" ] && kill -0 "$(cat "${PID_FILE}")" 2>/dev/null; then
    say "Server is running (PID $(cat "${PID_FILE}")). Logs: ${LOG_FILE}"
  else
    warn "Server is not running."
  fi
}

if [[ "${1:-}" == "stop" ]];   then stop_server_bg; exit 0; fi
if [[ "${1:-}" == "status" ]]; then status_server; exit 0; fi
if [[ "${1:-}" == "start" ]];  then start_server_bg; status_server; exit 0; fi
if [[ "${1:-}" == "logs" ]];   then [ -f "${LOG_FILE}" ] && tail -f "${LOG_FILE}" || err "No log file."; exit 0; fi

say "Scaffolding project in: ${APP_DIR}"
mkdir -p "${APP_DIR}"
cd "${APP_DIR}"

mkdir -p src/scipaper/{api/v1/routers,agents,core,sources,utils} tests ${RUN_DIR}

# -------------------------- pyproject.toml --------------------------
cat > pyproject.toml <<'PY'
[project]
name = "scipaper-cli"
version = "1.0.0"
description = "Modular, OA-first scientific paper tool (FastAPI + CLI + optional Agent)."
requires-python = ">=3.9"
readme = "README.md"
authors = [{ name = "SciPaper CLI Maintainers", email = "maintainers@scipaper-cli.local" }]
license = "MIT"

dependencies = [
  "fastapi>=0.115.0",
  "uvicorn>=0.30.0",
  "pydantic>=2.7.0",
  "pydantic-settings>=2.3.0",
  "httpx>=0.27.0",
  "click>=8.1.7",
  "rich>=13.7.1",
  "loguru>=0.7.2",
  "arxiv>=2.1.0",
  "pandas>=2.2.2",
  "matplotlib>=3.9.0",
  "pytest>=8.2.0",
  "openai>=1.40.0"
]

[project.optional-dependencies]
agents = ["openai-agents>=0.4.0"]

[project.scripts]
scipaper = "scipaper.cli:main"

[build-system]
requires = ["setuptools>=70.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]

[tool.pytest.ini_options]
addopts = "-q"
PY

# -------------------------- README.md --------------------------
cat > README.md <<'MD'
# scipaper-cli

OA-first scientific paper tool: FastAPI microservice + CLI, with optional Agent orchestration.

## Quick start

```bash
python3 -m venv .venv && source .venv/bin/activate
pip install -U pip
pip install -e .
make serve
scipaper health

Agent (optional)

Set OPENAI_API_KEY and install .[agents] to enable the Agent endpoint, or the API will return 501.
MD

––––––––––––– Makefile –––––––––––––

cat > Makefile <<‘MK’
VENV=.venv
PY=$(VENV)/bin/python
PIP=$(VENV)/bin/pip
UVICORN=$(PY) -m uvicorn

setup:
python3 -m venv $(VENV); . $(VENV)/bin/activate; 
$(PIP) install -U pip wheel; 
$(PIP) install -e .

test:
$(PY) -m pytest

serve:
$(UVICORN) scipaper.main:app –host 127.0.0.1 –port 8000

.PHONY: setup test serve
MK

––––––––––––– src/scipaper/init.py –––––––––––––

cat > src/scipaper/init.py <<‘PY’
version = “1.0.0”
PY

––––––––––––– src/scipaper/config.py –––––––––––––

cat > src/scipaper/config.py <<‘PY’
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
FASTAPI_HOST: str = “127.0.0.1”
FASTAPI_PORT: int = 8000
OPENAI_API_KEY: str | None = None
ALLOW_UNAUTHORIZED_SOURCES: bool = False

model_config = SettingsConfigDict(env_file=".env", extra="allow")

settings = Settings()
PY

––––––––––––– src/scipaper/utils/init.py –––––––––––––

cat > src/scipaper/utils/init.py <<‘PY’

utils package

PY

––––––––––––– src/scipaper/utils/logging_setup.py –––––––––––––

cat > src/scipaper/utils/logging_setup.py <<‘PY’
from loguru import logger
import sys

def setup_logging(level: str = “INFO”):
logger.remove()
logger.add(sys.stderr, level=level, colorize=True,
format=”{time:YYYY-MM-DD HH:mm:ss} | {level: <7} | “
“{name}:{function}:{line} - {message}”,
backtrace=True, diagnose=True)
logger.add(“scipaper.log”, level=“DEBUG”, rotation=“10 MB”, compression=“zip”)
logger.opt(ansi=True).info(“Logging initialized”)
PY

––––––––––––– src/scipaper/utils/ids.py –––––––––––––

cat > src/scipaper/utils/ids.py <<‘PY’
import re

ARXIV_NEW = re.compile(r”^\d{4}.\d{4,5}(v\d+)?$”)
ARXIV_OLD = re.compile(r”^[a-z-]+(.[A-Z]{2})?/\d{7}(v\d+)?$”, re.I)
DOI_RX    = re.compile(r”^10.\d{4,9}/\S+$”, re.I)

def classify_identifier(s: str) -> str:
s = (s or “”).strip()
if s.startswith((“http://”,“https://”)): return “url”
if ARXIV_NEW.match(s) or ARXIV_OLD.match(s): return “arxiv”
if DOI_RX.match(s): return “doi”
return “unknown”
PY

––––––––––––– src/scipaper/api/init.py –––––––––––––

cat > src/scipaper/api/init.py <<‘PY’

api package

PY

––––––––––––– src/scipaper/api/v1/init.py –––––––––––––

cat > src/scipaper/api/v1/init.py <<‘PY’

v1 package

PY

––––––––––––– src/scipaper/api/v1/routers/init.py –––––––––––––

cat > src/scipaper/api/v1/routers/init.py <<‘PY’

routers package

PY

––––––––––––– src/scipaper/api/v1/routers/system.py –––––––––––––

cat > src/scipaper/api/v1/routers/system.py <<‘PY’
from fastapi import APIRouter
router = APIRouter()

@router.get(”/health”)
async def health():
return {“status”:“ok”,“message”:“SciPaper API is running!”}
PY

––––––––––––– src/scipaper/sources/init.py –––––––––––––

cat > src/scipaper/sources/init.py <<‘PY’

sources package

PY

––––––––––––– src/scipaper/sources/base_source.py –––––––––––––

cat > src/scipaper/sources/base_source.py <<‘PY’
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

class BaseSource(ABC):
name: str = “base”

@abstractmethod
async def search(self, query: str, limit: int, filters: Optional[dict] = None) -> List[Dict[str, Any]]:
    ...

PY

––––––––––––– src/scipaper/sources/arxiv.py –––––––––––––

cat > src/scipaper/sources/arxiv.py <<‘PY’
from typing import Any, Dict, List, Optional
from .base_source import BaseSource
import arxiv, asyncio
from datetime import datetime

class ArxivSource(BaseSource):
name = “arxiv”

async def search(self, query: str, limit: int, filters: Optional[dict] = None) -> List[Dict[str, Any]]:
    def _do():
        s = arxiv.Search(query=query, max_results=limit, sort_by=arxiv.SortCriterion.SubmittedDate)
        out = []
        for r in s.results():
            out.append({
                "id": r.entry_id.split("/")[-1].split("v")[0],
                "title": r.title,
                "authors": [a.name for a in r.authors],
                "date": r.published.strftime("%Y-%m-%d") if isinstance(r.published, datetime) else None,
                "abstract": r.summary,
                "journal": r.journal_ref or "arXiv",
                "doi": getattr(r, "doi", None),
                "url": r.pdf_url,
                "categories": list(getattr(r, "categories", []) or []),
                "source": "arxiv",
            })
        return out
    return await asyncio.to_thread(_do)

PY

––––––––––––– src/scipaper/core/init.py –––––––––––––

cat > src/scipaper/core/init.py <<‘PY’

core package

PY

––––––––––––– src/scipaper/core/fetcher.py –––––––––––––

cat > src/scipaper/core/fetcher.py <<‘PY’
from typing import Optional, Dict, Any, List
from pathlib import Path
from loguru import logger
import httpx
from scipaper.utils.ids import classify_identifier

class Fetcher:
def init(self, client: httpx.AsyncClient):
self.client = client

async def _attempt(self, url: str, path: Path) -> bool:
    try:
        async with self.client.stream("GET", url, follow_redirects=True, timeout=60) as r:
            r.raise_for_status()
            ctype = r.headers.get("content-type","").lower()
            if "pdf" not in ctype and not url.endswith(".pdf"):
                return False
            path.parent.mkdir(parents=True, exist_ok=True)
            tmp = path.with_suffix(".pdf.tmp")
            with open(tmp, "wb") as f:
                async for chunk in r.aiter_bytes():
                    f.write(chunk)
            tmp.rename(path)
            return True
    except Exception as e:
        logger.warning(f"download failed from {url}: {e}")
        return False

async def fetch(self, meta: Dict[str, Any], out_dir: Path, rename: bool=True) -> Optional[Path]:
    title = meta.get("title") or meta.get("id") or meta.get("doi") or "paper"
    safe = "".join(ch if ch.isalnum() or ch in (" ","-","_") else "_" for ch in title).strip().replace(" ","_")
    dest = out_dir / f"{safe}.pdf"

    urls: List[str] = []
    kind = classify_identifier(meta.get("id",""))
    if kind == "arxiv" and meta.get("id"):
        urls.append(f"https://arxiv.org/pdf/{meta['id']}.pdf")
    if meta.get("url"):
        urls.append(meta["url"])

    for u in urls:
        if await self._attempt(u, dest):
            logger.success(f"saved {dest}")
            return dest
    return None

PY

––––––––––––– src/scipaper/api/v1/routers/search.py –––––––––––––

cat > src/scipaper/api/v1/routers/search.py <<‘PY’
from fastapi import APIRouter
from pydantic import BaseModel
from typing import List, Dict, Any
from scipaper.sources.arxiv import ArxivSource

router = APIRouter()

class SearchRequest(BaseModel):
query: str
sources: List[str] = [“arxiv”]
limit: int = 10

@router.post(”/search”)
async def search(req: SearchRequest) -> Dict[str, Any]:
srcmap = {“arxiv”: ArxivSource()}
papers = []
for s in req.sources:
if s in srcmap:
papers.extend(await srcmap[s].search(req.query, req.limit))
# dedupe + sort (date desc)
seen, uniq = set(), []
for p in papers:
key = p.get(“doi”) or (p.get(“source”), p.get(“id”)) or p.get(“url”)
if key and key not in seen:
seen.add(key); uniq.append(p)
uniq = sorted(uniq, key=lambda x: x.get(“date”,””), reverse=True)
return {“papers”: uniq}
PY

––––––––––––– src/scipaper/api/v1/routers/fetch.py –––––––––––––

cat > src/scipaper/api/v1/routers/fetch.py <<‘PY’
from fastapi import APIRouter, Request, HTTPException
from pydantic import BaseModel
from pathlib import Path
from scipaper.core.fetcher import Fetcher
from scipaper.utils.ids import classify_identifier

router = APIRouter()

class FetchRequest(BaseModel):
identifier: str
output_dir: str = “downloads”
rename: bool = True

@router.post(”/fetch”)
async def fetch(req: FetchRequest, request: Request):
client = request.app.state.http
fetcher = Fetcher(client)
kind = classify_identifier(req.identifier)
meta = {
“id”: req.identifier,
“title”: req.identifier,
“source”: “arxiv” if kind == “arxiv” else “unknown”,
“url”: req.identifier if kind==“url” else None
}
path = await fetcher.fetch(meta, Path(req.output_dir), rename=req.rename)
if not path:
raise HTTPException(404, “Could not fetch via open-access routes.”)
return {“download_path”: str(path)}
PY

––––––––––––– src/scipaper/agents/init.py –––––––––––––

cat > src/scipaper/agents/init.py <<‘PY’

agents package

PY

––––––––––––– src/scipaper/agents/tools.py –––––––––––––

cat > src/scipaper/agents/tools.py <<‘PY’
from typing import Any, Dict, List
from scipaper.sources.arxiv import ArxivSource
from scipaper.core.fetcher import Fetcher
from scipaper.utils.ids import classify_identifier
import httpx

These imports are resolved only if Agents SDK is installed and this module is imported by paper_agents.

from agents import function_tool, RunContextWrapper  # type: ignore

class ToolCtx:
http: httpx.AsyncClient

@function_tool
async def tool_search(ctx: RunContextWrapper[ToolCtx], query: str, limit: int = 5) -> List[Dict[str, Any]]:
“”“Search arXiv and return a list of PaperMetadata dictionaries.”””
src = ArxivSource()
return await src.search(query=query, limit=limit)

@function_tool
async def tool_fetch(ctx: RunContextWrapper[ToolCtx], identifier: str, output_dir: str = “downloads”) -> str:
“”“Fetch by arXiv ID or PDF URL. Returns local file path or empty string.”””
kind = classify_identifier(identifier)
meta = {
“id”: identifier,
“title”: identifier,
“source”: “arxiv” if kind == “arxiv” else “unknown”,
“url”: identifier if kind == “url” else None
}
out = Path(output_dir)
out.mkdir(parents=True, exist_ok=True)
fetcher = Fetcher(ctx.context.http)
path = await fetcher.fetch(meta, out)
return str(path) if path else “”
PY

––––––––––––– src/scipaper/agents/paper_agents.py –––––––––––––

cat > src/scipaper/agents/paper_agents.py <<‘PY’
import os, httpx
try:
from agents import Agent, Runner, ModelSettings  # type: ignore
from openai import AsyncOpenAI
from scipaper.agents.tools import tool_search, tool_fetch
from agents.models.openai_responses import OpenAIResponsesModel  # type: ignore
AGENTS_AVAILABLE = True
except Exception:
AGENTS_AVAILABLE = False

async def run_agent(prompt: str, http_client: httpx.AsyncClient) -> str:
if not AGENTS_AVAILABLE:
return “Agent unavailable: install optional dependency ‘.[agents]’ to enable.”
api_key = os.getenv(“OPENAI_API_KEY”)
if not api_key:
return “Agent cannot run: OPENAI_API_KEY not set.”
model = OpenAIResponsesModel(model=“gpt-4.1-mini”, openai_client=AsyncOpenAI(api_key=api_key))
agent = Agent(
name=“PaperOps”,
instructions=“Prefer open-access sources (arXiv). Use tools to search and fetch. Summarize concisely.”,
model=model,
model_settings=ModelSettings(temperature=0.2, parallel_tool_calls=True),
tools=[tool_search, tool_fetch],
)
res = await Runner.run(agent, input=prompt, context={“http”: http_client})
return res.final_output
PY

––––––––––––– src/scipaper/agents/server.py –––––––––––––

cat > src/scipaper/agents/server.py <<‘PY’
from fastapi import APIRouter, Depends, HTTPException, Request
from pydantic import BaseModel
import httpx
from scipaper.agents.paper_agents import run_agent, AGENTS_AVAILABLE

router = APIRouter()

class AgentRunRequest(BaseModel):
prompt: str

async def get_http(request: Request) -> httpx.AsyncClient:
return request.app.state.http

@router.post(”/agents/run”)
async def agents_run(body: AgentRunRequest, http: httpx.AsyncClient = Depends(get_http)):
if not AGENTS_AVAILABLE:
raise HTTPException(status_code=501, detail=“Agents SDK not available. Install optional dependency ‘.[agents]’.”)
out = await run_agent(body.prompt, http)
return {“status”:“ok”,“final”: out}
PY

––––––––––––– src/scipaper/main.py –––––––––––––

cat > src/scipaper/main.py <<‘PY’
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import httpx
from scipaper.utils.logging_setup import setup_logging
from scipaper.api.v1.routers import system, search, fetch
from scipaper.agents.server import router as agents_router

setup_logging()

@asynccontextmanager
async def lifespan(app: FastAPI):
app.state.http = httpx.AsyncClient(timeout=60, follow_redirects=True)
yield
await app.state.http.aclose()

app = FastAPI(
title=“SciPaper API”,
description=“OA-first microservice for paper search/fetch”,
version=“1.0.0”,
lifespan=lifespan,
)

app.add_middleware(
CORSMiddleware,
allow_origins=[””], allow_credentials=True,
allow_methods=[””], allow_headers=[”*”],
)

app.include_router(system.router, prefix=”/api/v1”, tags=[“System”])
app.include_router(search.router, prefix=”/api/v1”, tags=[“Search”])
app.include_router(fetch.router,  prefix=”/api/v1”, tags=[“Fetch”])
app.include_router(agents_router, prefix=”/api/v1”, tags=[“Agents”])
PY

––––––––––––– src/scipaper/cli.py –––––––––––––

cat > src/scipaper/cli.py <<‘PY’
import click, httpx, asyncio, os
from rich.console import Console
from rich.table import Table

HOST=os.getenv(“FASTAPI_HOST”,“127.0.0.1”)
PORT=int(os.getenv(“FASTAPI_PORT”,“8000”))
BASE=f”http://{HOST}:{PORT}/api/v1”
console = Console()

def run_async(fn):
def wrap(*args, **kwargs):
return asyncio.run(fn(*args, **kwargs))
return wrap

@click.group()
def main():
“”“SciPaper CLI”””
pass

@main.command()
@run_async
async def health():
async with httpx.AsyncClient() as c:
r = await c.get(f”{BASE}/health”)
console.print(r.json())

@main.command()
@click.argument(“query”, type=str)
@click.option(”–source”,”-s”, multiple=True, default=[“arxiv”])
@click.option(”–limit”,”-l”, type=int, default=5)
@run_async
async def search(query: str, source, limit: int):
async with httpx.AsyncClient() as c:
payload = {“query”: query, “sources”: list(source), “limit”: limit}
r = await c.post(f”{BASE}/search”, json=payload)
r.raise_for_status()
data = r.json()[“papers”]
if not data:
console.print(”[yellow]No results[/yellow]”); return
t = Table(title=f”Results for ‘{query}’”)
for h in [“ID”,“Title”,“Authors”,“Date”,“DOI”,“Source”]:
t.add_column(h)
for p in data:
title = (p[“title”][:70]+”…”) if len(p[“title”])>70 else p[“title”]
authors = “, “.join(p.get(“authors”, [])[:2])
t.add_row(p.get(“id”,””), title, authors, p.get(“date”,””) or “—”,
p.get(“doi”,””) or “—”, p.get(“source”,””))
console.print(t)

@main.command()
@click.argument(“identifier”, type=str)
@click.option(”–output-dir”,”-o”, default=“downloads”)
@click.option(”–rename”, is_flag=True, default=True)
@run_async
async def fetch(identifier: str, output_dir: str, rename: bool):
async with httpx.AsyncClient() as c:
payload = {“identifier”: identifier, “output_dir”: output_dir, “rename”: rename}
r = await c.post(f”{BASE}/fetch”, json=payload)
if r.status_code != 200:
console.print(f”[red]Fetch failed:[/red] {r.text}”)
return
console.print(f”[green]Saved:[/green] {r.json()[‘download_path’]}”)

@main.command()
@click.argument(“task”, type=str)
@run_async
async def agent(task: str):
async with httpx.AsyncClient() as c:
r = await c.post(f”{BASE}/agents/run”, json={“prompt”: task})
if r.status_code == 501:
console.print(”[yellow]Agent not available. Install optional deps or set OPENAI_API_KEY.[/yellow]”)
return
r.raise_for_status()
console.print(r.json()[“final”])
PY

––––––––––––– tests/test_health.py –––––––––––––

cat > tests/test_health.py <<‘PY’
from fastapi.testclient import TestClient
from scipaper.main import app

def test_health():
c = TestClient(app)
r = c.get(”/api/v1/health”)
assert r.status_code == 200
assert r.json()[“status”] == “ok”
PY

––––––––––––– tests/test_ids.py –––––––––––––

cat > tests/test_ids.py <<‘PY’
from scipaper.utils.ids import classify_identifier

def test_id_classification():
assert classify_identifier(“2401.12345”) == “arxiv”
assert classify_identifier(“cs/0112017”) == “arxiv”
assert classify_identifier(“10.1145/12345.67890”) == “doi”
assert classify_identifier(“https://example.com/a.pdf”) == “url”
assert classify_identifier(“weird”) == “unknown”
PY

––––––––––––– Build & Install –––––––––––––

ensure_python
python3 -m venv .venv

shellcheck disable=SC1091

source .venv/bin/activate
python -m pip install -U pip wheel setuptools
pip install -e .


––––––––––––– Run Tests –––––––––––––

say “Running tests…”
pytest

––––––––––––– Launch Server & Health –––––––––––––

start_server_bg
health_check

––––––––––––– Verify CLI –––––––––––––

say “CLI health via entrypoint:”
.venv/bin/scipaper health || true

say “All set.”
say “Use ‘.venv/bin/scipaper –help’ for CLI usage.”
say “Manage server with:”
echo “  $0 status”
echo “  $0 stop”
echo “  $0 start”

